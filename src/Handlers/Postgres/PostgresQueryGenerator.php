<?php
declare(strict_types=1);

namespace Fyre\Forge\Handlers\Postgres;

use Fyre\Forge\Column;
use Fyre\Forge\Exceptions\ForgeException;
use Fyre\Forge\ForeignKey;
use Fyre\Forge\Index;
use Fyre\Forge\QueryGenerator;
use Fyre\Forge\Table;
use Override;

use function array_key_exists;
use function array_map;
use function implode;
use function strtoupper;

/**
 * PostgresQueryGenerator
 */
class PostgresQueryGenerator extends QueryGenerator
{
    /**
     * Generate SQL for adding a constraint.
     *
     * @param Index $index The Index.
     * @return string The SQL query.
     */
    public function buildAddConstraint(Index $index)
    {
        $sql = 'ADD ';

        if (!$index->isPrimary()) {
            $sql .= 'CONSTRAINT ';
        }

        $sql .= $this->buildConstraint($index);

        return $sql;
    }

    /**
     * Generate SQL for adding a foreign key to a table.
     *
     * @param ForeignKey $foreignKey The ForeignKey.
     * @param array $options The foreign key options.
     * @return string The SQL query.
     */
    public function buildAddForeignKey(ForeignKey $foreignKey): string
    {
        $sql = 'ADD ';
        $sql .= $this->buildForeignKey($foreignKey);

        return $sql;
    }

    /**
     * Generate SQL for changing a column's auto increment.
     *
     * @param Column $column The Column.
     * @return string The SQL query.
     */
    public function buildAlterColumnAutoIncrement(Column $column): string
    {
        $sql = 'ALTER COLUMN ';
        $sql .= $column->getName();

        if ($column->isAutoIncrement()) {
            $sql .= ' ADD GENERATED BY DEFAULT AS IDENTITY';
        } else {
            $sql .= ' DROP IDENTITY';
        }

        return $sql;
    }

    /**
     * Generate SQL for changing a column's default value.
     *
     * @param Column $column The Column.
     * @return string The SQL query.
     */
    public function buildAlterColumnDefault(Column $column): string
    {
        $sql = 'ALTER COLUMN ';
        $sql .= $column->getName();

        $default = $column->getDefault();

        if ($default === null) {
            $sql .= ' DROP DEFAULT';
        } else {
            $sql .= ' SET DEFAULT ';
            $sql .= $default;
        }

        return $sql;
    }

    /**
     * Generate SQL for changing whether a column is nullable.
     *
     * @param Column $column The Column.
     * @return string The SQL query.
     */
    public function buildAlterColumnNullable(Column $column): string
    {
        $sql = 'ALTER COLUMN ';
        $sql .= $column->getName();

        if ($column->isNullable()) {
            $sql .= ' DROP ';
        } else {
            $sql .= ' SET ';
        }

        $sql .= ' NOT NULL';

        return $sql;
    }

    /**
     * Generate SQL for changeing a column's type.
     *
     * @param Column $column The Column.
     * @param array $options The column options.
     * @return string The SQL query.
     */
    public function buildAlterColumnType(Column $column, array $options): string
    {
        $options['cast'] ??= false;

        $sql = 'ALTER COLUMN ';
        $sql .= $column->getName();
        $sql .= ' TYPE ';
        $sql .= static::buildColumnType($column);

        if ($options['cast']) {
            $sql .= ' USING CAST('.$column->getName().' AS '.strtoupper($column->getType()).')';
        }

        return $sql;
    }

    /**
     * Generate SQL for a column.
     *
     * @param Column $column The Column.
     * @return string The SQL query.
     */
    #[Override]
    public function buildColumn(Column $column): string
    {
        $sql = $column->getName();
        $sql .= ' ';
        $sql .= static::buildColumnType($column);

        if ($column->isNullable()) {
            $sql .= ' NULL';
        } else {
            $sql .= ' NOT NULL';
        }

        $default = $column->getDefault();

        if ($default !== null) {
            $sql .= ' DEFAULT ';
            $sql .= $default;
        }

        if ($column->isAutoIncrement()) {
            $sql .= ' GENERATED BY DEFAULT AS IDENTITY';
        }

        return $sql;
    }

    /**
     * Generate SQL for a column comment.
     *
     * @param Column $column The Column.
     * @return string The SQL query.
     */
    public function buildCommentOnColumn(Column $column): string
    {
        $sql = 'COMMENT ON COLUMN ';
        $sql .= $column->getTable()->getName();
        $sql .= '.';
        $sql .= $column->getName();
        $sql .= ' IS ';

        $comment = $column->getComment();

        if ($comment) {
            $sql .= $this->forge->getConnection()->quote($comment);
        } else {
            $sql .= 'NULL';
        }

        return $sql;
    }

    /**
     * Generate SQL for a table comment.
     *
     * @param Table $table The Table.
     * @return string The SQL query.
     */
    public function buildCommentOnTable(Table $table): string
    {
        $sql = 'COMMENT ON TABLE ';
        $sql .= $table->getName();
        $sql .= ' IS ';

        $comment = $table->getComment();

        if ($comment) {
            $sql .= $this->forge->getConnection()->quote($comment);
        } else {
            $sql .= 'NULL';
        }

        return $sql;
    }

    /**
     * Generate SQL for a constraint.
     *
     * @param Index $index The Index.
     * @return string The SQL query.
     *
     * @throws ForgeException if the constraint is not valid.
     */
    public function buildConstraint(Index $index): string
    {
        $type = $index->getType();

        if ($type !== 'btree') {
            throw ForgeException::forInvalidIndexType($type);
        }

        $columns = implode(', ', $index->getColumns());

        if ($index->isPrimary()) {
            return 'PRIMARY KEY ('.$columns.')';
        }

        if ($index->isUnique()) {
            return $index->getName().' UNIQUE ('.$columns.')';
        }

        throw ForgeException::forInvalidConstraint($index->getName());
    }

    /**
     * Generate SQL for creating a table index.
     *
     * @param Index $index The Index.
     * @return string The SQL query.
     */
    public function buildCreateIndex(Index $index): string
    {
        $tableName = $index->getTable()->getName();

        if ($index->isPrimary()) {
            $sql = 'ADD '.$this->buildConstraint($index);

            return $this->buildAlterTable($tableName, [$sql]);
        }

        if ($index->isUnique()) {
            $sql = $this->buildAddConstraint($index);

            return $this->buildAlterTable($tableName, [$sql]);
        }

        $sql = 'CREATE INDEX ';
        $sql .= $index->getName();
        $sql .= ' ON ';
        $sql .= $tableName;
        $sql .= ' USING ';
        $sql .= strtoupper($index->getType());
        $sql .= ' (';
        $sql .= implode(', ', $index->getColumns());
        $sql .= ')';

        return $sql;
    }

    /**
     * Generate SQL for creating a new schema.
     *
     * @param string $schema The schema name.
     * @param array $options The schema options.
     * @return string The SQL query.
     */
    public function buildCreateSchema(string $schema, array $options = []): string
    {
        $options['ifNotExists'] ??= false;

        $sql = 'CREATE SCHEMA ';

        if ($options['ifNotExists']) {
            $sql .= 'IF NOT EXISTS ';
        }

        $sql .= $schema;

        return $sql;
    }

    /**
     * Generate SQL for creating a new table.
     *
     * @param Table $table The Table.
     * @param array $options The table options.
     * @return string The SQL query.
     */
    #[Override]
    public function buildCreateTable(Table $table, array $options = []): string
    {
        $options['ifNotExists'] ??= false;

        $columns = $table->columns();
        $indexes = $table->indexes();
        $foreignKeys = $table->foreignKeys();

        $definitions = array_map(
            fn(Column $column) => $this->buildColumn($column),
            $columns
        );

        foreach ($indexes as $name => $index) {
            if (array_key_exists($name, $foreignKeys)) {
                continue;
            }

            if ($index->isPrimary()) {
                $definitions[] = $this->buildConstraint($index);
            } else if ($index->isUnique()) {
                $definitions[] = 'CONSTRAINT '.$this->buildConstraint($index);
            } else {
                continue;
            }
        }

        foreach ($foreignKeys as $foreignKey) {
            $definitions[] = $this->buildForeignKey($foreignKey);
        }

        $sql = 'CREATE TABLE ';

        if ($options['ifNotExists']) {
            $sql .= 'IF NOT EXISTS ';
        }

        $sql .= $table->getName();

        $sql .= ' (';
        $sql .= implode(', ', $definitions);
        $sql .= ')';

        return $sql;
    }

    /**
     * Generate SQL for dropping a constraint from a table.
     *
     * @param string $index The index name.
     * @return string The SQL query.
     */
    public function buildDropConstraint(string $index): string
    {
        $sql = 'DROP CONSTRAINT ';
        $sql .= $index;

        return $sql;
    }

    /**
     * Generate SQL for dropping a schema.
     *
     * @param string $schema The schema name.
     * @param array $options The options for dropping the schema.
     * @return string The SQL query.
     */
    public function buildDropSchema(string $schema, array $options = []): string
    {
        $options['ifExists'] ??= false;

        $sql = 'DROP SCHEMA ';

        if ($options['ifExists']) {
            $sql .= 'IF EXISTS ';
        }

        $sql .= $schema;

        return $sql;
    }

    /**
     * Generate SQL for a foreign key.
     *
     * @param ForeignKey $foreignKey The ForeignKey.
     * @return string The SQL query.
     */
    #[Override]
    public function buildForeignKey(ForeignKey $foreignKey): string
    {
        $sql = parent::buildForeignKey($foreignKey);
        $sql .= ' DEFERRABLE INITIALLY IMMEDIATE';

        return $sql;
    }

    /**
     * Generate SQL for a column type.
     *
     * @param Column $type The Column.
     * @return string The SQL query.
     */
    protected static function buildColumnType(Column $column): string
    {
        $type = $column->getType();
        $length = $column->getLength();
        $precision = $column->getPrecision();

        $sql = strtoupper($type);

        if ($length !== null) {
            switch ($type) {
                case 'bpchar':
                case 'character':
                case 'character varying':
                    $sql .= '(';
                    $sql .= $length;
                    $sql .= ')';
                    break;
                case 'numeric':
                    $sql .= '(';
                    $sql .= $length;
                    if ($precision) {
                        $sql .= ',';
                        $sql .= $precision;
                    }
                    $sql .= ')';
                    break;
            }
        } else if ($precision !== null) {
            switch ($type) {
                case 'time without time zone':
                    $sql = 'TIME';
                    $sql .= '(';
                    $sql .= $precision;
                    $sql .= ')';
                    $sql .= ' WITHOUT TIME ZONE';
                    break;
                case 'timestamp without time zone':
                    $sql = 'TIMESTAMP';
                    $sql .= '(';
                    $sql .= $precision;
                    $sql .= ')';
                    $sql .= ' WITHOUT TIME ZONE';
                    break;
                case 'timestamp with time zone':
                    $sql = 'TIMESTAMP';
                    $sql .= '(';
                    $sql .= $precision;
                    $sql .= ')';
                    $sql .= ' WITH TIME ZONE';
                    break;
            }
        }

        return $sql;
    }
}
